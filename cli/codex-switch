#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERSION_FILE="$SCRIPT_DIR/../VERSION"

CODEX_DIR="${CODEX_HOME:-$HOME/.codex}"
AUTH="$CODEX_DIR/auth.json"
PROFILES_DIR="$CODEX_DIR/profiles"
LOCK_DIR="$CODEX_DIR/.codex-switch.lock"
LOCK_TIMEOUT="${CODEX_SWITCH_LOCK_TIMEOUT:-10}"

OUTPUT_MODE="${CODEX_SWITCH_OUTPUT:-auto}"
if [[ "$OUTPUT_MODE" != "auto" && "$OUTPUT_MODE" != "plain" && "$OUTPUT_MODE" != "json" ]]; then
  OUTPUT_MODE="auto"
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    --plain)
      if [[ "$OUTPUT_MODE" == "json" ]]; then
        echo "Error: --plain and --json cannot be used together." >&2
        exit 2
      fi
      OUTPUT_MODE="plain"
      shift
      ;;
    --json)
      if [[ "$OUTPUT_MODE" == "plain" ]]; then
        echo "Error: --plain and --json cannot be used together." >&2
        exit 2
      fi
      OUTPUT_MODE="json"
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
  esac
done

DECORATED_OUTPUT=false
if [[ "$OUTPUT_MODE" == "auto" && -t 1 ]]; then
  DECORATED_OUTPUT=true
fi

if [[ "$DECORATED_OUTPUT" == true ]]; then
  RED=$'\033[0;31m'
  GREEN=$'\033[0;32m'
  YELLOW=$'\033[0;33m'
  CYAN=$'\033[0;36m'
  DIM=$'\033[2m'
  BOLD=$'\033[1m'
  RESET=$'\033[0m'

  ICO_BRAND="âœ¦"
  ICO_OK="âœ“"
  ICO_FAIL="âœ—"
  ICO_ARROW="â†’"
  ICO_ZAP="âš¡"
  ICO_KEY="ðŸ”‘"
  ICO_ACTIVE="â–¸"
else
  RED=''
  GREEN=''
  YELLOW=''
  CYAN=''
  DIM=''
  BOLD=''
  RESET=''

  ICO_BRAND='*'
  ICO_OK='OK'
  ICO_FAIL='ERROR'
  ICO_ARROW='->'
  ICO_ZAP='*'
  ICO_KEY='fingerprint:'
  ICO_ACTIVE='*'
fi

LOCK_HELD=false

# ---- Helpers ------------------------------------------------------------

json_escape() {
  local input="$1"
  input=${input//\\/\\\\}
  input=${input//\"/\\\"}
  input=${input//$'\n'/\\n}
  input=${input//$'\r'/\\r}
  input=${input//$'\t'/\\t}
  printf '%s' "$input"
}

print_json_error() {
  local message="$1"
  local code="${2:-1}"
  printf '{"ok":false,"error":"%s","code":%s}\n' "$(json_escape "$message")" "$code" >&2
}

die() {
  local message="$1"
  local code="${2:-1}"
  if [[ "$OUTPUT_MODE" == "json" ]]; then
    print_json_error "$message" "$code"
  else
    echo "${RED}${ICO_FAIL} Error:${RESET} $message" >&2
  fi
  exit "$code"
}

banner() {
  [[ "$DECORATED_OUTPUT" == true ]] || return 0
  echo ""
  echo "${CYAN}${BOLD}  ${ICO_BRAND} codex-switch${RESET}  ${DIM}- profile manager${RESET}"
  echo "${DIM}  ----------------------------${RESET}"
}

read_version() {
  if [[ -f "$VERSION_FILE" ]]; then
    tr -d '[:space:]' < "$VERSION_FILE"
  else
    echo "dev"
  fi
}

set_mode() {
  local target="$1"
  local mode="$2"
  chmod "$mode" "$target" 2>/dev/null || die "Failed to set permissions on $target to $mode."
}

perm_lockdown() {
  mkdir -p "$PROFILES_DIR" || die "Failed to create profile directory: $PROFILES_DIR"
  set_mode "$CODEX_DIR" 700
  set_mode "$PROFILES_DIR" 700
  if [[ -f "$AUTH" ]]; then
    set_mode "$AUTH" 600
  fi
}

release_lock() {
  if [[ "$LOCK_HELD" == true ]]; then
    rm -rf "$LOCK_DIR" 2>/dev/null || true
    LOCK_HELD=false
  fi
}

acquire_lock() {
  mkdir -p "$CODEX_DIR" || die "Failed to create CODEX directory: $CODEX_DIR"

  local waited=0
  while ! mkdir "$LOCK_DIR" 2>/dev/null; do
    if [[ -f "$LOCK_DIR/pid" ]]; then
      local holder_pid
      holder_pid="$(cat "$LOCK_DIR/pid" 2>/dev/null || true)"
      if [[ -n "$holder_pid" ]] && ! kill -0 "$holder_pid" 2>/dev/null; then
        rm -rf "$LOCK_DIR" 2>/dev/null || true
        continue
      fi
    fi

    if (( waited >= LOCK_TIMEOUT )); then
      die "Could not acquire lock after ${LOCK_TIMEOUT}s: $LOCK_DIR"
    fi

    sleep 1
    waited=$((waited + 1))
  done

  printf '%s\n' "$$" > "$LOCK_DIR/pid" 2>/dev/null || true
  LOCK_HELD=true
}

trap release_lock EXIT INT TERM HUP

atomic_copy() {
  local source_file="$1"
  local target_file="$2"
  local mode="$3"
  local target_dir
  local tmp_file

  target_dir="$(dirname "$target_file")"
  mkdir -p "$target_dir" || die "Failed to create directory: $target_dir"
  tmp_file="$(mktemp "$target_dir/.codex-switch.tmp.XXXXXX")" || die "Failed to create temporary file in $target_dir"

  cp -f "$source_file" "$tmp_file" || {
    rm -f "$tmp_file" 2>/dev/null || true
    die "Failed to copy $source_file"
  }

  set_mode "$tmp_file" "$mode"

  mv -f "$tmp_file" "$target_file" || {
    rm -f "$tmp_file" 2>/dev/null || true
    die "Failed to replace $target_file"
  }
}

stream_profiles() {
  [[ -d "$PROFILES_DIR" ]] || return 0

  while IFS= read -r file_path; do
    file_name="${file_path##*/}"
    printf '%s\n' "${file_name%.json}"
  done < <(find "$PROFILES_DIR" -maxdepth 1 -type f -name '*.json' -print 2>/dev/null | sort)
}

load_profiles_array() {
  PROFILES=()
  while IFS= read -r profile_name; do
    [[ -n "$profile_name" ]] && PROFILES+=("$profile_name")
  done < <(stream_profiles)
}

validate_name() {
  local name="$1"
  if [[ -z "$name" ]]; then
    die "Profile name is required." 2
  fi

  if [[ ! "$name" =~ ^[A-Za-z0-9._-]+$ ]]; then
    die "Invalid profile name: $name (allowed: A-Z a-z 0-9 . _ -)" 2
  fi
}

print_ok_message() {
  local message="$1"
  if [[ "$OUTPUT_MODE" == "json" ]]; then
    printf '{"ok":true,"message":"%s"}\n' "$(json_escape "$message")"
  else
    echo "${GREEN}${ICO_OK}${RESET} $message"
  fi
}

print_save_result() {
  local name="$1"
  local profile_path="$2"

  if [[ "$OUTPUT_MODE" == "json" ]]; then
    printf '{"ok":true,"action":"save","profile":"%s","path":"%s"}\n' \
      "$(json_escape "$name")" "$(json_escape "$profile_path")"
  elif [[ "$DECORATED_OUTPUT" == true ]]; then
    echo "${GREEN}${ICO_OK}${RESET} Saved profile: ${BOLD}$name${RESET}"
  else
    echo "Saved profile: $name"
  fi
}

print_use_result() {
  local name="$1"

  if [[ "$OUTPUT_MODE" == "json" ]]; then
    printf '{"ok":true,"action":"use","profile":"%s","auth":"%s"}\n' \
      "$(json_escape "$name")" "$(json_escape "$AUTH")"
  elif [[ "$DECORATED_OUTPUT" == true ]]; then
    echo "${CYAN}${ICO_ZAP} Switched ${ICO_ARROW} ${BOLD}$name${RESET}"
  else
    echo "Switched -> $name"
  fi
}

print_delete_result() {
  local name="$1"

  if [[ "$OUTPUT_MODE" == "json" ]]; then
    printf '{"ok":true,"action":"delete","profile":"%s"}\n' "$(json_escape "$name")"
  elif [[ "$DECORATED_OUTPUT" == true ]]; then
    echo "${YELLOW}${ICO_FAIL} Deleted profile: ${BOLD}$name${RESET}"
  else
    echo "Deleted profile: $name"
  fi
}

print_rename_result() {
  local old_name="$1"
  local new_name="$2"

  if [[ "$OUTPUT_MODE" == "json" ]]; then
    printf '{"ok":true,"action":"rename","old":"%s","new":"%s"}\n' \
      "$(json_escape "$old_name")" "$(json_escape "$new_name")"
  elif [[ "$DECORATED_OUTPUT" == true ]]; then
    echo "${CYAN}${ICO_ARROW} Renamed: ${BOLD}$old_name${RESET} ${ICO_ARROW} ${BOLD}$new_name${RESET}"
  else
    echo "Renamed: $old_name -> $new_name"
  fi
}

usage() {
  banner
  local version
  version="$(read_version)"

  echo ""
  echo "  ${BOLD}Version:${RESET} $version"
  echo ""
  echo "  ${BOLD}Usage:${RESET}"
  echo "    codex-switch [--plain|--json] <command> [args]"
  echo ""
  echo "  ${BOLD}Commands:${RESET}"
  echo "    ${GREEN}init${RESET}                  Set up profiles directory"
  echo "    ${GREEN}save${RESET}  <name>          Save current auth as a profile"
  echo "    ${GREEN}use${RESET}   <name>          Switch to a saved profile"
  echo "    ${GREEN}list${RESET}                  List saved profiles"
  echo "    ${GREEN}who${RESET}                   Show current auth fingerprint"
  echo "    ${GREEN}path${RESET}                  Show resolved paths"
  echo "    ${GREEN}delete${RESET} <name>         Delete a profile"
  echo "    ${GREEN}rename${RESET} <old> <new>    Rename a profile"
  echo "    ${GREEN}pick${RESET}                  Interactive profile selector"
  echo "    ${GREEN}ui${RESET}                    Alias for pick"
  echo "    ${GREEN}version${RESET}               Print tool version"
  echo "    ${GREEN}help${RESET}                  Show this help"
  echo ""
}

# ---- Commands -----------------------------------------------------------

cmd="${1:-}"
case "$cmd" in
  init)
    acquire_lock
    perm_lockdown
    if [[ "$OUTPUT_MODE" == "json" ]]; then
      printf '{"ok":true,"action":"init","profiles_dir":"%s"}\n' "$(json_escape "$PROFILES_DIR")"
    else
      print_ok_message "Initialized profiles directory: $PROFILES_DIR"
    fi
    ;;

  save)
    name="${2:-}"
    validate_name "$name"

    acquire_lock
    [[ -f "$AUTH" ]] || die "Missing auth file: $AUTH. Hint: run 'codex login' first."
    perm_lockdown

    profile_path="$PROFILES_DIR/$name.json"
    atomic_copy "$AUTH" "$profile_path" 600
    print_save_result "$name" "$profile_path"
    ;;

  use)
    name="${2:-}"
    validate_name "$name"

    acquire_lock
    profile_path="$PROFILES_DIR/$name.json"
    [[ -f "$profile_path" ]] || die "Profile not found: $name (looked in: $profile_path)"
    perm_lockdown

    atomic_copy "$profile_path" "$AUTH" 600
    print_use_result "$name"
    ;;

  list)
    profiles="$(stream_profiles)"
    [[ -z "$profiles" ]] && exit 0

    if [[ "$OUTPUT_MODE" == "json" ]]; then
      active_fp=""
      if [[ -f "$AUTH" ]]; then
        if command -v shasum >/dev/null 2>&1; then
          active_fp="$(shasum -a 256 "$AUTH" | awk '{print $1}')"
        else
          active_fp="$(openssl dgst -sha256 "$AUTH" | awk '{print $2}')"
        fi
      fi

      printf '{"ok":true,"profiles":['
      first=1
      while IFS= read -r p; do
        pfile="$PROFILES_DIR/$p.json"
        if command -v shasum >/dev/null 2>&1; then
          pfp="$(shasum -a 256 "$pfile" | awk '{print $1}')"
        else
          pfp="$(openssl dgst -sha256 "$pfile" | awk '{print $2}')"
        fi

        active=false
        if [[ -n "$active_fp" && "$pfp" == "$active_fp" ]]; then
          active=true
        fi

        if [[ $first -eq 0 ]]; then
          printf ','
        fi
        first=0

        printf '{"name":"%s","fingerprint":"%s","active":%s}' \
          "$(json_escape "$p")" "$(json_escape "$pfp")" "$active"
      done <<< "$profiles"
      printf ']}\n'
      exit 0
    fi

    if [[ "$DECORATED_OUTPUT" == false ]]; then
      echo "$profiles"
      exit 0
    fi

    active_fp=""
    if [[ -f "$AUTH" ]]; then
      if command -v shasum >/dev/null 2>&1; then
        active_fp="$(shasum -a 256 "$AUTH" | awk '{print $1}')"
      else
        active_fp="$(openssl dgst -sha256 "$AUTH" | awk '{print $2}')"
      fi
    fi

    echo ""
    echo "  ${BOLD}Profiles${RESET}"
    echo "  ${DIM}----------------------------${RESET}"
    while IFS= read -r p; do
      pfile="$PROFILES_DIR/$p.json"
      if command -v shasum >/dev/null 2>&1; then
        pfp="$(shasum -a 256 "$pfile" | awk '{print $1}')"
      else
        pfp="$(openssl dgst -sha256 "$pfile" | awk '{print $2}')"
      fi
      short="${pfp:0:12}"

      if [[ "$pfp" == "$active_fp" ]]; then
        echo "  ${GREEN}${ICO_ACTIVE} ${BOLD}$p${RESET}  ${DIM}$short${RESET}  ${GREEN}active${RESET}"
      else
        echo "    $p  ${DIM}$short${RESET}"
      fi
    done <<< "$profiles"
    echo ""
    ;;

  who)
    [[ -f "$AUTH" ]] || die "Not logged in (missing $AUTH)"
    if command -v shasum >/dev/null 2>&1; then
      fp="$(shasum -a 256 "$AUTH" | awk '{print $1}')"
    else
      fp="$(openssl dgst -sha256 "$AUTH" | awk '{print $2}')"
    fi

    if [[ "$OUTPUT_MODE" == "json" ]]; then
      printf '{"ok":true,"fingerprint":"%s"}\n' "$(json_escape "$fp")"
    elif [[ "$DECORATED_OUTPUT" == true ]]; then
      echo "${ICO_KEY}  ${BOLD}$fp${RESET}"
    else
      echo "$fp"
    fi
    ;;

  path)
    if [[ "$OUTPUT_MODE" == "json" ]]; then
      printf '{"ok":true,"codex_home":"%s","codex_dir":"%s","auth":"%s","profiles_dir":"%s"}\n' \
        "$(json_escape "${CODEX_HOME:-}")" \
        "$(json_escape "$CODEX_DIR")" \
        "$(json_escape "$AUTH")" \
        "$(json_escape "$PROFILES_DIR")"
    elif [[ "$DECORATED_OUTPUT" == false ]]; then
      echo "CODEX_HOME=${CODEX_HOME:-}"
      echo "CODEX_DIR=$CODEX_DIR"
      echo "AUTH=$AUTH"
      echo "PROFILES_DIR=$PROFILES_DIR"
    else
      echo ""
      echo "  ${BOLD}Resolved Paths${RESET}"
      echo "  ${DIM}----------------------------${RESET}"
      echo "  ${CYAN}CODEX_HOME${RESET}     = ${CODEX_HOME:-${DIM}(not set)${RESET}}"
      echo "  ${CYAN}CODEX_DIR${RESET}      = $CODEX_DIR"
      echo "  ${CYAN}AUTH${RESET}           = $AUTH"
      echo "  ${CYAN}PROFILES_DIR${RESET}   = $PROFILES_DIR"
      echo ""
    fi
    ;;

  delete)
    name="${2:-}"
    validate_name "$name"

    acquire_lock
    profile_path="$PROFILES_DIR/$name.json"
    [[ -f "$profile_path" ]] || die "Profile not found: $name"

    rm -f "$profile_path" || die "Failed to delete profile: $name"
    perm_lockdown
    print_delete_result "$name"
    ;;

  rename)
    old_name="${2:-}"
    new_name="${3:-}"
    validate_name "$old_name"
    validate_name "$new_name"

    acquire_lock
    old_path="$PROFILES_DIR/$old_name.json"
    new_path="$PROFILES_DIR/$new_name.json"

    [[ -f "$old_path" ]] || die "Profile not found: $old_name"
    [[ ! -f "$new_path" ]] || die "Profile already exists: $new_name"

    mv "$old_path" "$new_path" || die "Failed to rename profile: $old_name"
    set_mode "$new_path" 600
    perm_lockdown
    print_rename_result "$old_name" "$new_name"
    ;;

  ui|pick)
    [[ "$OUTPUT_MODE" == "json" ]] && die "pick/ui does not support --json output" 2

    load_profiles_array
    if [[ ${#PROFILES[@]} -eq 0 ]]; then
      die "No profiles found."
    fi

    banner
    echo ""

    selected=""
    if command -v fzf >/dev/null 2>&1; then
      selected=$(printf "%s\n" "${PROFILES[@]}" | fzf \
        --height 12 \
        --border rounded \
        --header "  ${ICO_ZAP} Pick a profile" \
        --prompt "  ${ICO_ARROW} " \
        --pointer "${ICO_ACTIVE}" \
        --color "header:cyan,pointer:green,prompt:cyan" \
        --ansi) || exit 0
    else
      echo "  ${BOLD}Select a profile:${RESET}"
      echo ""
      PS3="  ${CYAN}${ICO_ARROW}${RESET} Choice [1-${#PROFILES[@]}, or 'q' to quit]: "
      select opt in "${PROFILES[@]}"; do
        if [[ -n "$opt" ]]; then
          selected="$opt"
          break
        elif [[ "$REPLY" == "q" ]]; then
          echo ""
          echo "  ${DIM}Canceled.${RESET}"
          exit 0
        else
          echo "  ${RED}Invalid selection: $REPLY${RESET}"
        fi
      done
    fi

    if [[ -n "$selected" ]]; then
      "$0" use "$selected"
      current_fp="$("$0" --plain who 2>/dev/null || true)"
      [[ -n "$current_fp" ]] && echo "${DIM}  fingerprint: $current_fp${RESET}"
    fi
    ;;

  version)
    version="$(read_version)"
    if [[ "$OUTPUT_MODE" == "json" ]]; then
      printf '{"ok":true,"version":"%s"}\n' "$(json_escape "$version")"
    else
      echo "$version"
    fi
    ;;

  ""|help|-h|--help)
    usage
    ;;

  *)
    die "Unknown command: $cmd" 2
    ;;
esac
